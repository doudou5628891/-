### JVM

.class文件输入到JVM中，加载并执行该类文件   进入运行时数据区

这部分整体上包含两个部分｛1.所有线程共享的内存块。2.线程私有的内存块。｝

共享块中包含有  方法区 and Heap堆

私有内存块中包含有   虚拟机栈 本地方法栈 程序计数器

程序计数器：记录当前线程的正在执行的指令位置

虚拟机栈：虚拟机栈是Java方法执行的内存结构，虚拟机会在每一个Java方法执行时，创建一个“栈帧”，用于存储局部变量表，操作数栈，动态链接，方法出口

本地方法栈：本地方法栈保存本地方法信息，每一个线程都会创建一个单独的本地方栈。

(栈区：每个线程都会创建一个单独的运行时栈，每一次方法调用都会在栈内存中创建一个栈帧。所有局部变量将在栈内存中创建。栈区线程安全)





堆：存放程序运行过程中创建的对象实例，GC主要是针对堆回收的（还有方法区的常量池）

方法区：用于存储被JVM加载的类的信息，常量，静态变量

##### 垃圾回收算法：

###### 标记-清除

标记要回收的对象，然后统一回收

缺点:标记清除效率不高，会产生大量不连续的内存碎片

###### 标记-整理

将标记的对象都向一端移动，然后直接清除掉边界之外的对象

缺点：移动操作复杂，效率较低

###### 复制回收

内存划分两块每次只使用一块，将标记的复制到一遍，然后清除另一边，效率高但空间减半

新生代使用复制回收算法

老年代使用标记清除或标记整理

###### 内存分配与回收策略



### 红黑树

普通二叉查找树 在极端情况下可能回退化成链表，此时查找效率比较低



为了避免这种情况，出现了AVL，RB树。

首先普通的AVL就是在插入数据时保证每个节点的左右子树高小于等于1，每一个子树均为平衡二叉树



根是黑色

节点是红色或者黑色

所有叶子节点都是黑色

每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上都不能有两个连续的红色节点）

从任一节点到每个叶子的所有简单路径都包含相同数目的黑色节点（黑高）

这些限制可以避免二查查找树退化成单链表的情况

后面说的这两个性质可以保证任意节点到其每个叶子节点路径最长  不超过最短路径的2倍

