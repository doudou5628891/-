https://tech.meituan.com/2014/06/30/mysql-index.html

# MySQL索引原理(巩固)以及慢查询优化

## 背景

大部分应用系统中，读写比例在10：1左右，插入操作和一般更新操作很少出现性能问题。最容易遇到问题的是一些复杂的查询操作，所以查询语句的优化是重中之重。

一个慢查询引发的思考

```mysql
select
	count(*)
from
	task
where
	status = 2
	and operator_id = 20839
	and operator_time>1371169729
	and operator_time<1371174603
	and type = 2
# 系统使用者反应系统中某功能对应的SQL语句越来越慢
```

多数情况下，我们知道索引能够提高查询效率，但应该如何建立索引？索引的顺序如何？许多人却只知道大概。其实理解这些概念并不难，而且索引的原理远没有想象的那么复杂。

## MYSQL索引原理

索引目的：提高查询效率

索引原理：搜索树平均时间复杂度Ig(N)。

## 磁盘IO与预读

磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为**寻道时间**、**旋转延迟**、**传输时间**三个部分。

**寻道时间**：磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms一下；

**旋转延迟**：即磁盘转速，如磁盘7200转表示每分钟能转7200次，即一秒120次，旋转延迟就是1/120 /2 = 4.17ms；

**传输时间**：从磁盘读取 或 将数据写入磁盘的时间，一般在0.?毫秒，可以不计。

所以一次磁盘IO耗时大约9.17ms左右。

但一台500-MIPS的机器每秒可以执行**5亿条指令**，换算一下，一次IO时间可以执行40万条指令。

各个硬件延迟：

![image-20221020160914228](C:\Users\MSi\AppData\Roaming\Typora\typora-user-images\image-20221020160914228.png)

考虑磁盘IO代价昂贵，计算机系统优化为：一次IO时，不光获取当前磁盘地址数据，也会把相邻数据也都读取到内存缓冲区内，即**局部预读性原理**。所以，一次IO读取的数据称之为   **一页**(page)。具体一页有多少数据跟操作系统有关，一般为4k(32)或8k(64)。也就是说，**当我们读取一页内的数据时，实际上才发生了一次IO**。

![image-20221020161423515](C:\Users\MSi\AppData\Roaming\Typora\typora-user-images\image-20221020161423515.png)

上图为一颗B+树。非叶子节点不存储真实的数据，只存储**指引搜索方向的数据项**。

如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

## B+树的性质

1.IO次数取决于B+树的高度h。若某表数据为N个，每个磁盘块的数据项的数量为m，则h=log(m+1)N，数据量N一定的情况下，m越大，h越小；而 m=磁盘块的大小(固定)/数据项的大小，磁盘块的大小也就是一个数据页的大小。可以推出，如果数据项占的空间越小，数据项数量就越多，树的高度就越低。**这就是为什么每个数据项，即索引字段要尽量小**，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放在叶子节点而不是内层节点，一旦放到内层，每个磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表

2.当B+树的数据项是复合数据结构时，即复合索引。B+树是按照从左到右的顺序来建立搜索树的。比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

1.**最左前缀匹配原则**，非常重要的原则，mysql会一直向右匹配直到**遇到范围查询(>、<、between、like)就停止匹配**，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的**顺序可以任意调整**。

2.**=和in可以乱序**，比如a = 1 and b = 2 and c = 3 **建立(a,b,c)索引可以任意顺序**，mysql的查询优化器会帮你优化成索引可以识别的形式。

3.尽量选择**区分度高的列**作为索引，**区分度的公式是count(distinct col)/count(*)**，**表示字段不重复的比例**，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，**即平均1条扫描10条记录。**

4.**索引列不能参与计算**，保持列“干净”，比如**from_unixtime(create_time) = ’2014-05-29’**就不能使用到索引，原因很简单，**b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。**所以语句应该写成**create_time = unix_timestamp(’2014-05-29’)。**  

**5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。**

### 慢查询优化基本步骤

0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE

1.where条件单表查，**锁定最小返回记录表**。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，**单表每个字段分别查询，看哪个字段的区分度最高**

2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）

3.**order by limit 形式的sql语句让排序的表优先查**

4.了解业务方使用场景

5.**加索引时参照建索引的几大原则**

6.观察结果，不符合预期继续从0分析

# 2.分解关联查询

碰到的问题，在service层，面对这样的一个问题。

是否应该先用DAO跟据user名字获取id，再去关联表中查数据

还是直接sql 写好关联查询呢？

![img](https://img2020.cnblogs.com/blog/1158910/202011/1158910-20201119141643288-1744298130.png)

